# WebGPU Background (webgpu-bg)

A project demonstrating WebAssembly Component Model integration with WebGPU in a Vite + React frontend.

## Architecture Overview

This project uses the **WASM Component Model** to run WebGPU code written in Rust (or other languages) in the browser. The architecture consists of:

1. **Background (`bg/`)**: Rust code compiled to a WASM Component
2. **Frontend (`frontend/`)**: React + Vite application that transpiles and runs the WASM component
3. **Transpilation**: `jco` converts the WASM component into JavaScript bindings
4. **Runtime**: `gfx.js` provides WebGPU/WASI bindings that bridge browser APIs to WASI interfaces via [wasi-gfx](https://github.com/WebAssembly/wasi-gfx)

## Project Structure

```
webgpu-bg/
├── bg/                          # Rust WASM component source
│   └── bin/
│       └── triangle.wasm        # Compiled WASM component
└── frontend/                    # React + Vite frontend
    ├── src/
    │   ├── lib/
    │   │   └── gfx.js           # WebGPU/WASI bindings (source)
    │   ├── wasm/
    │   │   └── generated/      # Generated by jco transpile (gitignored)
    │   │       ├── triangle.js  # Transpiled JS bindings
    │   │       ├── triangle.d.ts
    │   │       └── interfaces/
    │   └── App.tsx              # React app (imports @wasm/triangle.js)
    ├── vite-plugin-jco-transpile.ts  # Auto-transpiles WASM on build
    └── vite.config.ts           # Vite config with WASI externals
```

## How It Works

### 1. WASM Component Model

The WASM Component Model uses **WIT (WebAssembly Interface Types)** to define interfaces between components. Our component:
- **Exports**: `wasi:cli/run@0.2.0` - the main `run()` function
- **Imports**: WASI interfaces like `wasi:webgpu/webgpu`, `wasi:surface/surface`, etc.
- These interfaces need **runtime implementations** provided by `gfx.js`

### 2. Transpilation Process

The `vite-plugin-jco-transpile` plugin automatically runs `jco transpile` before dev/build:

**Key aspects:**
- `--async-mode jspi`: Enables async/await in WASM (needed for WebGPU). This means you need [JSPI support](https://caniuse.com/mdn-webassembly_jspi) in your browser
- `--map`: Maps WASI interfaces to implementations:
  - Standard WASI (filesystem, io, etc.) → CDN shims
  - Custom WebGPU interfaces from wasi-gfx → `./lib/gfx.js`

### 3. Vite Integration

**Import in React:**
```typescript
import { run as wasiCliRun } from '@wasm/triangle.js'

useEffect(() => {
  wasiCliRun.run()  // Async function
}, [])
```

**Vite Configuration:**
- **Alias**: `@wasm` → `src/wasm/generated/`
- **External**: WASI interfaces marked as external (not bundled, resolved at runtime)
- **OptimizeDeps**: WASI interfaces excluded from pre-bundling

**Why external?** WASI interfaces are resolved at runtime through the mappings, not npm packages. Rolldown needs to know not to bundle them.

### 4. Runtime Resolution

The generated `triangle.js` imports:
- `../../lib/gfx.js` - WebGPU/WASI bindings (relative path)
- CDN URLs - Standard WASI shims

Vite resolves these imports, and at runtime:
- `gfx.js` provides WebGPU implementations
- CDN shims provide standard WASI polyfills

## File Organization

### Source Files
- `src/lib/gfx.js`: WebGPU/WASI bindings (version controlled)
- `src/wasm/generated/`: Generated files (gitignored, regenerated on build)

### Why This Structure?
- **Vite-idiomatic**: Generated files in `src/`, not `public/`
- **No duplication**: Direct reference to `gfx.js` (no copying)
- **Clear separation**: Source vs generated code
- **Type-safe**: TypeScript paths configured for `@wasm` alias

## Usage

### Prerequisites

### Development
```bash
cd frontend
bun install
bun run dev
```

The plugin automatically:
1. Transpiles via our `vite-plugin-jco-transpile` plugin
2. Starts the Vite dev server
3. Hot Module Replacement works for both React and WASM code

### Build
```bash
bun run build
```

## Key Concepts

### WASM Component Model
- **Components**: Encapsulate one or more WASM modules
- **WIT Interfaces**: Define component contracts (imports/exports)
- **Runtime Mappings**: Connect interface definitions to implementations

### JSPI (JavaScript Promise Integration)
- Allows WASM to suspend/resume execution
- Enables true async/await in WASM code
- Required for WebGPU's async operations

### Rolldown-Vite External Configuration
- WASI interfaces are **not npm packages**
- They're resolved at runtime through mappings
- Must be marked as `external` so rolldown doesn't try to bundle them

## Troubleshooting

**WASM file missing**: Build the component in `bg/` directory first

**Import errors**: Check that `src/lib/gfx.js` exists and paths are correct

**Module resolution errors**: Verify `@wasm` alias in `vite.config.ts` and `tsconfig.app.json`

